# Nerdle Equations and Analysis Repository
All the possible equations for the Nerdle game (includes Mini, Classic and Maxi), a solver and some analysis.

- The 'Raw' files contains all the equations that Python evaluates as True, which spans almost all possible equations that can be inserted in the Nerdle game, with the exception of numbers that contain leading zeroes.
- The 'Restricted' files are a filtered version of their respective raws accounting for the fact that nerdle's answers only contain numbers after the = symbol, that there are no lone zeroes, and that there aren't sequences of operations, such as '+-' or '*+'. These are probably the most important, as they reflect the most probable answers to the puzzles. The Maxi list of equations doesn't have this name because it wasn't generated by filtering a 'Raw' file
- The 'Pairs' files contain all the pairs of equations for their respective game modes that contain all symbols, which could provide a better human strategy. In the case of the Maxi Nerdle, there isn't any pair that follows the rules of the game, and, for this case, lone zeroes and a more flexible position of + and - operators were allowed. 

- wordle.py is the solver based on information theory. You enter what you inserted in the Nerdle website ("1+4*3=13" for example) and the mask returned by the game. A mask is a sequence of 0s, 1s or 2s that represent the colors of the equation you inserted. 0s are black, 1s are purple and 2s are green. Next, the algorithm will return the next optimal choice. Also, note that it assumes all equations are equally likely. Don't forget to add the path to the text file. 

Here are the best first choices considering each file:

| File              | Best choice   | Average information | Best pair   | Average information |
| ----------------- | ------------- | ------------------- | ------------- | ------------------- |
| MiniRaw           |     1=+3-2    |       6.5558        |     -    |       -        |
| MiniRestricted    |    4*7=28     |       5.8203        |     -    |       -        |
| ClassicRaw        | To be checked |    To be checked    |     -    |       -        |
| ClassicRestricted |    48-32=16   |        9.7751       |     30/2-8=7 and 5*9+1=46    |       13.1561        |
| Maxi              |   75+2-31=46\* |      12.7317        |     3²+(0/7)=9 and 2*61-4³=58\*    |       18.1243        |

*Best found _so far_

### How were the Maxi equations generated?
The Classic and Mini were generated by brute force, testing all possible combinations of symbols. That's how the "Raw" files were created and then filtered to the "Restricted" ones. However, for the Maxi Nerdle, this would not be feasible, as there are more than 6 trillion possible expressions. In this way, a more efficient approach was needed. The idea is:
1. Only the LHS of the equation needs to be generated. After generating it, it is only necessary to parse and calculate it, and see if the resulting equation fits the 10 character length. It also needs to be <= 8 characters long, as at least 2 are for the = symbol and the RHS.
2. The LHSs are generated step by step, in which the next character to be added depends on the last one.

Consider the following sets of symbols

$D=[0,1,2,3,4,5,6,7,8,9]$

$O=[-,+,*,/]$

$E=[²,³]$

Then the logic for *Last symbol (LS) -> Symbols that can come after* is

- If there are no last symbol (the expression has just begun) $\rightarrow D^* \cup [(]$ 
- $\text{LS} \in D \rightarrow D \cup O \cup E$
- $\text{LS} \in O \rightarrow D^* \cup [(]$
- $\text{LS} \in E \rightarrow O$
- $\text{LS} = ( \rightarrow D^* \cup [(]$
- $\text{LS} = ) \rightarrow O \cup E$

The set of symbols that can come after the LS can also include ) if there are opened parenthesis, except if LS is (. 

With this method, at any step, if the there are no opened parenthesis, the expression will always be a valid one. It only needs to be evaluated to see if it meets Nerdle restrictions, that is, if the result is a non-negative integer and the resulting equation has the desired length.

I do not know if it is possible to make this more efficient. Because every expression generated by this method is valid, I believe the only way to make it more efficient is to compute the value of the expression *while* generating it, in order to more intelligently select the next possible symbols. For instance, if the expression is currently "152³" it is known that it needs to be divided or subtracted next, because then the result won't fit within 10 characters, for example.
